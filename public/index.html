<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcripteur Vocal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 700px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2rem;
            font-weight: 600;
        }

        .recorder-section {
            margin-bottom: 30px;
        }

        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 2rem;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .record-button.idle {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #ff3838, #c0392b);
            animation: pulse 1.5s infinite;
        }

        .record-button.processing {
            background: linear-gradient(135deg, #ffa726, #ff9800);
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .status {
            font-size: 1.1rem;
            margin-bottom: 20px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status.idle { color: #666; }
        .status.recording { color: #ff3838; font-weight: bold; }
        .status.processing { color: #ff9800; font-weight: bold; }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ff3838;
            margin-bottom: 20px;
        }

        .transcript-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #f1f1f1;
        }

        .transcript-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 100px;
            text-align: left;
            line-height: 1.6;
            color: #333;
            border: 2px dashed #ddd;
            transition: all 0.3s ease;
        }

        .transcript-box.has-content {
            border: 2px solid #667eea;
            background: #f0f4ff;
        }

        .transcript-box.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
        }

        .error {
            color: #e74c3c;
            background: #ffeaea;
            border: 2px solid #e74c3c;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .permissions-warning {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #ffeaa7;
        }

        .copy-button {
            background: linear-gradient(135deg, #10ac84, #00d2d3);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
            display: none;
        }

        .copy-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 172, 132, 0.3);
        }

        .copy-button.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .model-selection {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }

        .model-selection h4 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-align: center;
        }

        .model-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .model-button {
            flex: 1;
            max-width: 200px;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            text-align: center;
        }

        .model-button.flash {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: white;
        }

        .model-button.flash:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }

        .model-button.pro {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .model-button.pro:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .model-info {
            font-size: 0.8rem;
            opacity: 0.9;
            margin-top: 5px;
        }

        .cost-info {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.85rem;
            color: #2e7d2e;
            display: none;
        }

        .cost-info.show {
            display: block;
        }

        .cost-details {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-family: monospace;
        }

        .error-retry {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            color: #856404;
            display: none;
        }

        .error-retry.show {
            display: block;
        }

        .retry-button {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

        .retry-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(243, 156, 18, 0.3);
        }

        .retry-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 600px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .record-button {
                width: 100px;
                height: 100px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üéôÔ∏è Transcripteur Vocal</h1>

    <div id="permissionsWarning" class="permissions-warning" style="display: none;">
        Veuillez autoriser l'acc√®s au microphone pour utiliser cette application.
    </div>

    <div class="recorder-section">
        <button id="recordButton" class="record-button idle">
            <span id="recordIcon">üéôÔ∏è</span>
        </button>

        <div id="status" class="status idle">
            Cliquez pour commencer l'enregistrement
        </div>

        <div id="timer" class="timer" style="display: none;">
            00:00
        </div>
    </div>

    <div id="modelSelection" class="model-selection">
        <h4>ü§ñ Choisissez le mod√®le de transcription :</h4>
        <div class="model-buttons">
            <button id="flashButton" class="model-button flash">
                ‚ö° Rapide
                <div class="model-info">Gemini Flash - R√©ponse quasi instantan√©e</div>
            </button>
            <button id="proButton" class="model-button pro">
                üèÜ Pr√©cis
                <div class="model-info">Gemini Pro - Lent mais qualit√© maximale</div>
            </button>
        </div>
    </div>

    <div class="transcript-section">
        <h3>Transcription :</h3>
        <div id="transcriptBox" class="transcript-box">
            Votre transcription appara√Ætra ici...
        </div>
        <button id="copyButton" class="copy-button">
            üìã Copier
        </button>
        <div id="costInfo" class="cost-info">
            üí∞ Co√ªt: <span id="costAmount"></span>
            <div class="cost-details">
                <span>Tokens entr√©e: <span id="inputTokens"></span></span>
                <span>Tokens sortie: <span id="outputTokens"></span></span>
            </div>
        </div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="errorRetry" class="error-retry">
            ‚ö†Ô∏è <span id="retryMessage"></span>
            <br>
            <button id="retryButton" class="retry-button">
                üîÑ Ressayer la transcription
            </button>
        </div>
    </div>
</div>

<script>
    class VoiceRecorder {
        constructor() {
            this.mediaRecorder = null;
            this.audioChunks = [];
            this.isRecording = false;
            this.startTime = null;
            this.timerInterval = null;

            this.recordButton = document.getElementById('recordButton');
            this.status = document.getElementById('status');
            this.timer = document.getElementById('timer');
            this.transcriptBox = document.getElementById('transcriptBox');
            this.errorDiv = document.getElementById('error');
            this.permissionsWarning = document.getElementById('permissionsWarning');
            this.recordIcon = document.getElementById('recordIcon');
            this.copyButton = document.getElementById('copyButton');
            this.modelSelection = document.getElementById('modelSelection');
            this.flashButton = document.getElementById('flashButton');
            this.proButton = document.getElementById('proButton');
            this.recordedAudio = null;
            this.costInfo = document.getElementById('costInfo');
            this.costAmount = document.getElementById('costAmount');
            this.inputTokens = document.getElementById('inputTokens');
            this.outputTokens = document.getElementById('outputTokens');
            this.errorRetry = document.getElementById('errorRetry');
            this.retryMessage = document.getElementById('retryMessage');
            this.retryButton = document.getElementById('retryButton');
            this.lastModelType = null;

            this.init();
        }

        async init() {
            try {
                // Demander permission microphone
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    }
                });

                this.mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                this.setupMediaRecorder();
                this.recordButton.addEventListener('click', () => this.toggleRecording());
                this.copyButton.addEventListener('click', () => this.copyToClipboard());
                this.flashButton.addEventListener('click', () => this.processWithModel('flash'));
                this.proButton.addEventListener('click', () => this.processWithModel('pro'));
                this.retryButton.addEventListener('click', () => this.retryLastRequest());

            } catch (error) {
                console.error('Erreur d\'acc√®s au microphone:', error);
                this.showPermissionsWarning();
            }
        }

        setupMediaRecorder() {
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                this.processRecording();
            };
        }

        toggleRecording() {
            if (!this.isRecording) {
                this.startRecording();
            } else {
                this.stopRecording();
            }
        }

        startRecording() {
            if (!this.mediaRecorder) {
                this.showError('Microphone non disponible');
                return;
            }

            this.audioChunks = [];
            this.isRecording = true;
            this.startTime = Date.now();

            this.mediaRecorder.start(100); // Collecte des chunks toutes les 100ms

            this.updateUI('recording');
            this.startTimer();
            this.hideError();
        }

        stopRecording() {
            if (!this.isRecording) return;

            this.isRecording = false;
            this.mediaRecorder.stop();
            this.stopTimer();
            // Ne pas passer en mode processing imm√©diatement
            // Le processRecording() va g√©rer l'√©tat
        }

        async processRecording() {
            // Cr√©er le blob audio et le stocker
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });

            if (audioBlob.size === 0) {
                this.showError('Enregistrement vide');
                this.updateUI('idle');
                return;
            }

            this.recordedAudio = audioBlob;
            
            // Afficher le choix de mod√®le
            this.updateUI('model-selection');
            this.modelSelection.style.display = 'block';
        }

        async processWithModel(modelType) {
            this.lastModelType = modelType; // Sauvegarder le mod√®le pour retry
            
            try {
                this.modelSelection.style.display = 'none';
                this.errorRetry.classList.remove('show');
                this.updateUI('processing');

                // Envoyer au backend avec le mod√®le choisi
                const formData = new FormData();
                formData.append('audio', this.recordedAudio, 'recording.webm');
                formData.append('model', modelType);

                const response = await fetch('/api/transcribe', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    this.showTranscript(result.content);
                    if (result.cost) {
                        this.showCost(result.cost);
                    }
                } else {
                    throw new Error(result.error || 'Erreur de transcription');
                }

            } catch (error) {
                console.error('Erreur:', error);
                this.showRetryError(error.message, modelType);
            } finally {
                this.updateUI('idle');
            }
        }

        showRetryError(errorMessage, modelType) {
            const isRetryableError = errorMessage.includes('503') || 
                                   errorMessage.includes('overloaded') ||
                                   errorMessage.includes('500') ||
                                   errorMessage.includes('429');
            
            if (isRetryableError) {
                this.retryMessage.textContent = `Le mod√®le ${modelType === 'flash' ? 'Gemini Flash' : 'Gemini Pro'} est surcharg√©. Vous pouvez ressayer dans quelques instants.`;
                this.errorRetry.classList.add('show');
            } else {
                this.showError('Erreur lors de la transcription: ' + errorMessage);
            }
        }

        async retryLastRequest() {
            if (!this.recordedAudio || !this.lastModelType) return;
            
            this.retryButton.disabled = true;
            this.retryButton.textContent = '‚è≥ Nouvelle tentative...';
            
            // Attendre 2 secondes avant de ressayer
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            this.retryButton.disabled = false;
            this.retryButton.textContent = 'üîÑ Ressayer la transcription';
            
            await this.processWithModel(this.lastModelType);
        }

        updateUI(state) {
            this.recordButton.className = `record-button ${state}`;

            switch (state) {
                case 'idle':
                    this.status.textContent = 'Cliquez pour commencer l\'enregistrement';
                    this.status.className = 'status idle';
                    this.recordIcon.textContent = 'üéôÔ∏è';
                    this.timer.style.display = 'none';
                    break;
                case 'recording':
                    this.status.textContent = 'Enregistrement en cours... Cliquez pour arr√™ter';
                    this.status.className = 'status recording';
                    this.recordIcon.textContent = '‚èπÔ∏è';
                    this.timer.style.display = 'block';
                    break;
                case 'model-selection':
                    this.status.textContent = 'Enregistrement termin√© - Choisissez le mod√®le';
                    this.status.className = 'status idle';
                    this.recordIcon.textContent = 'üéôÔ∏è';
                    this.timer.style.display = 'none';
                    break;
                case 'processing':
                    this.status.textContent = 'Transcription en cours...';
                    this.status.className = 'status processing';
                    this.recordIcon.textContent = '‚è≥';
                    this.timer.style.display = 'none';
                    this.showLoadingTranscript();
                    break;
            }
        }

        startTimer() {
            this.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                this.timer.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        stopTimer() {
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }

        showTranscript(text) {
            // Convertir les retours √† la ligne en HTML
            const formattedText = text.replace(/\n/g, '<br>');
            this.transcriptBox.innerHTML = formattedText;
            this.transcriptBox.classList.add('has-content');
            this.copyButton.style.display = 'inline-block';
            this.currentText = text;
        }

        showLoadingTranscript() {
            this.transcriptBox.innerHTML = '<div class="loader"></div>Transcription en cours...';
            this.transcriptBox.classList.add('loading');
            this.transcriptBox.classList.remove('has-content');
        }

        showError(message) {
            this.errorDiv.textContent = message;
            this.errorDiv.style.display = 'block';
            this.errorRetry.classList.remove('show');
        }

        hideError() {
            this.errorDiv.style.display = 'none';
            this.errorRetry.classList.remove('show');
        }

        showPermissionsWarning() {
            this.permissionsWarning.style.display = 'block';
            this.recordButton.disabled = true;
            this.status.textContent = 'Acc√®s au microphone requis';
            this.status.className = 'status error';
        }

        showCost(costData) {
            const costEUR = costData.totalEUR.toFixed(6);
            this.costAmount.textContent = `${costEUR}‚Ç¨ (${costData.model})`;
            this.inputTokens.textContent = costData.inputTokens;
            this.outputTokens.textContent = costData.outputTokens;
            this.costInfo.classList.add('show');
        }

        async copyToClipboard() {
            if (!this.currentText) return;
            
            try {
                await navigator.clipboard.writeText(this.currentText);
                this.copyButton.textContent = '‚úÖ Copi√©!';
                this.copyButton.classList.add('success');
                
                setTimeout(() => {
                    this.copyButton.textContent = 'üìã Copier';
                    this.copyButton.classList.remove('success');
                }, 2000);
            } catch (error) {
                console.error('Erreur de copie:', error);
                this.showError('Impossible de copier dans le presse-papier');
            }
        }
    }

    // Initialiser l'application
    document.addEventListener('DOMContentLoaded', () => {
        new VoiceRecorder();
    });
</script>
</body>
</html>